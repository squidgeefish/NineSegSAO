#include "ch32fun.h"
#include "i2c-slave.h"
#include <stdio.h>

void writeVFD(uint16_t);

// Programming one-liner:
//  make; python -m mpremote cp vfd-sao.bin :.; python -m mpremote eval "programSAO(1)"

static const unsigned char rands[] = {
	0x67, 0xc6, 0x69, 0x73, 0x51, 0xff, 0x4a, 0xec, 0x29, 0xcd, 0xba, 0xab, 0xf2, 0xfb, 0xe3, 0x46, 
	0x7c, 0xc2, 0x54, 0xf8, 0x1b, 0xe8, 0xe7, 0x8d, 0x76, 0x5a, 0x2e, 0x63, 0x33, 0x9f, 0xc9, 0x9a, 
	0x66, 0x32, 0x0d, 0xb7, 0x31, 0x58, 0xa3, 0x5a, 0x25, 0x5d, 0x05, 0x17, 0x58, 0xe9, 0x5e, 0xd4, 
	0xab, 0xb2, 0xcd, 0xc6, 0x9b, 0xb4, 0x54, 0x11, 0x0e, 0x82, 0x74, 0x41, 0x21, 0x3d, 0xdc, 0x87, 
	0x70, 0xe9, 0x3e, 0xa1, 0x41, 0xe1, 0xfc, 0x67, 0x3e, 0x01, 0x7e, 0x97, 0xea, 0xdc, 0x6b, 0x96, 
	0x8f, 0x38, 0x5c, 0x2a, 0xec, 0xb0, 0x3b, 0xfb, 0x32, 0xaf, 0x3c, 0x54, 0xec, 0x18, 0xdb, 0x5c, 
	0x02, 0x1a, 0xfe, 0x43, 0xfb, 0xfa, 0xaa, 0x3a, 0xfb, 0x29, 0xd1, 0xe6, 0x05, 0x3c, 0x7c, 0x94, 
	0x75, 0xd8, 0xbe, 0x61, 0x89, 0xf9, 0x5c, 0xbb, 0xa8, 0x99, 0x0f, 0x95, 0xb1, 0xeb, 0xf1, 0xb3, 
	0x05, 0xef, 0xf7, 0x00, 0xe9, 0xa1, 0x3a, 0xe5, 0xca, 0x0b, 0xcb, 0xd0, 0x48, 0x47, 0x64, 0xbd, 
	0x1f, 0x23, 0x1e, 0xa8, 0x1c, 0x7b, 0x64, 0xc5, 0x14, 0x73, 0x5a, 0xc5, 0x5e, 0x4b, 0x79, 0x63, 
	0x3b, 0x70, 0x64, 0x24, 0x11, 0x9e, 0x09, 0xdc, 0xaa, 0xd4, 0xac, 0xf2, 0x1b, 0x10, 0xaf, 0x3b, 
	0x33, 0xcd, 0xe3, 0x50, 0x48, 0x47, 0x15, 0x5c, 0xbb, 0x6f, 0x22, 0x19, 0xba, 0x9b, 0x7d, 0xf5, 
	0x0b, 0xe1, 0x1a, 0x1c, 0x7f, 0x23, 0xf8, 0x29, 0xf8, 0xa4, 0x1b, 0x13, 0xb5, 0xca, 0x4e, 0xe8, 
	0x98, 0x32, 0x38, 0xe0, 0x79, 0x4d, 0x3d, 0x34, 0xbc, 0x5f, 0x4e, 0x77, 0xfa, 0xcb, 0x6c, 0x05, 
	0xac, 0x86, 0x21, 0x2b, 0xaa, 0x1a, 0x55, 0xa2, 0xbe, 0x70, 0xb5, 0x73, 0x3b, 0x04, 0x5c, 0xd3, 
	0x36, 0x94, 0xb3, 0xaf, 0xe2, 0xf0, 0xe4, 0x9e, 0x4f, 0x32, 0x15, 0x49, 0xfd, 0x82, 0x4e, 0xa9, };
static const unsigned char sintable[] = {
	0x80, 0x83, 0x86, 0x89, 0x8c, 0x8f, 0x92, 0x95, 0x99, 0x9c, 0x9f, 0xa2, 0xa5, 0xa8, 0xab, 0xad, 
	0xb0, 0xb3, 0xb6, 0xb9, 0xbc, 0xbe, 0xc1, 0xc4, 0xc6, 0xc9, 0xcb, 0xce, 0xd0, 0xd3, 0xd5, 0xd7, 
	0xda, 0xdc, 0xde, 0xe0, 0xe2, 0xe4, 0xe6, 0xe8, 0xe9, 0xeb, 0xed, 0xee, 0xf0, 0xf1, 0xf3, 0xf4, 
	0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfc, 0xfd, 0xfe, 0xfe, 0xfe, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xfe, 0xfe, 0xfe, 0xfd, 0xfc, 0xfc, 0xfb, 0xfa, 0xf9, 0xf8, 0xf7, 0xf6, 
	0xf5, 0xf4, 0xf3, 0xf1, 0xf0, 0xee, 0xed, 0xeb, 0xe9, 0xe8, 0xe6, 0xe4, 0xe2, 0xe0, 0xde, 0xdc, 
	0xda, 0xd7, 0xd5, 0xd3, 0xd0, 0xce, 0xcb, 0xc9, 0xc6, 0xc4, 0xc1, 0xbe, 0xbc, 0xb9, 0xb6, 0xb3, 
	0xb0, 0xad, 0xab, 0xa8, 0xa5, 0xa2, 0x9f, 0x9c, 0x99, 0x95, 0x92, 0x8f, 0x8c, 0x89, 0x86, 0x83, 
	0x80, 0x7d, 0x79, 0x76, 0x73, 0x70, 0x6d, 0x6a, 0x67, 0x64, 0x61, 0x5e, 0x5b, 0x58, 0x55, 0x52, 
	0x4f, 0x4c, 0x49, 0x47, 0x44, 0x41, 0x3e, 0x3c, 0x39, 0x36, 0x34, 0x31, 0x2f, 0x2d, 0x2a, 0x28, 
	0x26, 0x24, 0x21, 0x1f, 0x1d, 0x1b, 0x1a, 0x18, 0x16, 0x14, 0x13, 0x11, 0x10, 0x0e, 0x0d, 0x0b, 
	0x0a, 0x09, 0x08, 0x07, 0x06, 0x05, 0x04, 0x04, 0x03, 0x02, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 
	0x0a, 0x0b, 0x0d, 0x0e, 0x10, 0x11, 0x13, 0x14, 0x16, 0x18, 0x1a, 0x1b, 0x1d, 0x1f, 0x21, 0x24, 
	0x26, 0x28, 0x2a, 0x2d, 0x2f, 0x31, 0x34, 0x36, 0x39, 0x3c, 0x3e, 0x41, 0x44, 0x47, 0x49, 0x4c, 
	0x4f, 0x52, 0x55, 0x58, 0x5b, 0x5e, 0x61, 0x64, 0x67, 0x6a, 0x6d, 0x70, 0x73, 0x76, 0x79, 0x7d, };

#define SEG_C  (1 << 0)
#define SEG_DP (1 << 1)
#define SEG_B  (1 << 2)
#define SEG_A  (1 << 3)
#define SEG_H  (1 << 4)
#define SEG_G  (1 << 5)
#define SEG_F  (1 << 6)
#define SEG_E  (1 << 7)
#define SEG_D  (1 << 8)
#define SEG_I  (1 << 9)

#define HV_DAT PA1
#define HV_CLK PA2
#define HV_LATCH PC4

// Index 0 - Mode
//         - Mode 0: cnlohr pulsing "shader"
//         - Mode 1: Random Numbers
//         - Mode 2: Discrete Number (reads from index 1)
// Index 1 - Number
// Index 2 - Decimal Point (only for modes 1 and 2)

#define MODE 0
#define INDEX 1
#define DECIMAL 2

#define MODE_SHADER 0
#define MODE_NUMBERS 1
#define MODE_DISCRETE 2

volatile uint8_t i2c_registers[3] = {0x00};

// shifts LSB-first
void writeVFD(uint16_t pattern)
{
    if ((i2c_registers[MODE] != MODE_SHADER) && (i2c_registers[DECIMAL])) pattern |= SEG_DP;

    for (int i=0; i<10; ++i)
    {
        funDigitalWrite(HV_DAT, pattern & 1);

        pattern >>= 1;
        funDigitalWrite(HV_CLK, FUN_LOW);
        funDigitalWrite(HV_CLK, FUN_HIGH);
    }

    funDigitalWrite(HV_LATCH, FUN_HIGH);
    funDigitalWrite(HV_LATCH, FUN_LOW);
}

// i2c callback
void onWrite(uint8_t reg, uint8_t length) {
    // printf(" b\n");
}

int main() {
    SystemInit();
    funGpioInitAll();

    // Initialize I2C slave
    funPinMode(PC1, GPIO_CFGLR_OUT_10Mhz_AF_OD); // SDA
    funPinMode(PC2, GPIO_CFGLR_OUT_10Mhz_AF_OD); // SCL
    SetupI2CSlave(0x9, i2c_registers, sizeof(i2c_registers), onWrite, NULL, false);

    funPinMode(HV_DAT, GPIO_CFGLR_OUT_10Mhz_PP);
    funPinMode(HV_CLK, GPIO_CFGLR_OUT_10Mhz_PP);
    funPinMode(HV_LATCH, GPIO_CFGLR_OUT_10Mhz_PP);
    
    funDigitalWrite(HV_LATCH, FUN_LOW);
    funDigitalWrite(HV_CLK, FUN_HIGH);

//#define SEVEN_SEG

    uint32_t numbers[] = {
#ifdef SEVEN_SEG
        SEG_A | SEG_B | SEG_C | SEG_D | SEG_E | SEG_F,
                SEG_B | SEG_C,
        SEG_A | SEG_B |         SEG_D | SEG_E |         SEG_G,
        SEG_A | SEG_B | SEG_C | SEG_D |                 SEG_G,
                SEG_B | SEG_C |                 SEG_F | SEG_G,
        SEG_A |         SEG_C | SEG_D |         SEG_F | SEG_G,
        SEG_A |         SEG_C | SEG_D | SEG_E | SEG_F | SEG_G,
        SEG_A | SEG_B | SEG_C,
        SEG_A | SEG_B | SEG_C | SEG_D | SEG_E | SEG_F | SEG_G,
        SEG_A | SEG_B | SEG_C | SEG_D |         SEG_F | SEG_G
#else
        SEG_A | SEG_B | SEG_C | SEG_D | SEG_E | SEG_F,
                SEG_B | SEG_C |                                 SEG_H,
        SEG_A | SEG_B |         SEG_D | SEG_E |         SEG_G,
        SEG_A |         SEG_C | SEG_D |                 SEG_G | SEG_H,
                SEG_B | SEG_C |                 SEG_F | SEG_G,
        SEG_A |         SEG_C | SEG_D |         SEG_F | SEG_G,
        SEG_A |         SEG_C | SEG_D | SEG_E | SEG_F | SEG_G,
        SEG_A |                                                 SEG_H | SEG_I,
        SEG_A | SEG_B | SEG_C | SEG_D | SEG_E | SEG_F | SEG_G,
        SEG_A | SEG_B | SEG_C | SEG_D |         SEG_F | SEG_G
#endif // SEVEN_SEG
    };

    int i = 0;
	uint32_t last_sec;
	int secframect = 0;

	uint32_t phases[10] = { 0 };
	for( i = 0; i < 10; i++ ) phases[i] = i<<16;

	static uint16_t segrun[256];

    i2c_registers[MODE] = MODE_DISCRETE;
    i2c_registers[INDEX] = 3;

	last_sec = SysTick->CNT;
    while (1)
    {
        // t = 6MHz
        uint32_t t = SysTick->CNT;

//        secframect++;
//        if( (int32_t)(t-last_sec) > 5*6000000 )
//        {
//            //printf( "%d\n", secframect );
//            secframect = 0;
//            last_sec += 5*6000000;
//            i2c_registers[MODE]++;
//            i2c_registers[MODE] %= 3;
//        } 
//
        asm volatile (""::: "memory");

        if (i2c_registers[MODE] == MODE_SHADER)      
        {
            uint16_t runword = 0;

            uint16_t segtime[10];

            for( i = 0; i < 10; i++ )
            {
                phases[i] += ((((rands[i&0xff])+0xf)<<2)<<1)>>2;

                uint8_t index = (phases[i])>>11;
                uint8_t rsbase = sintable[index];
                int val = rsbase;//huetable[rsbase];
                val = val * 2;
                val -= 64;
                if( val < 0 ) val = 0;
                if( val > 255 ) val = 255;
                segtime[i] = val;

            }

            for( i = 0; i < 10; i++ )
            {
                segrun[255-segtime[i]] |= 1<<i;
            }

            for( i = 0; i < 255; i++ )
            {
                runword ^= segrun[i];
                writeVFD( runword );
            }

            for( i = 0; i < 10; i++ )
            {
                segrun[255-segtime[i]] = 0;
            }

            writeVFD( 0 );
        }
        else if (i2c_registers[MODE] == MODE_NUMBERS)
        {
            // t = 6MHz
            uint32_t start = SysTick->CNT;

            int digitbase = (start>>22)%10;
            int midbase = (start>>13)&0x1ff;

            int inext = digitbase + 1;
            if( inext == 10 ) inext = 0;


            midbase -= 64;
            if( midbase < 0 ) { midbase = 0;            writeVFD(numbers[digitbase]); continue; }

            if( midbase > 255 ) { midbase = 255;              writeVFD(numbers[inext]); continue; }

            midbase *= 64;
            uint32_t mid = start+midbase;
            uint32_t end = start+(64*255);

            writeVFD(numbers[inext]);
            while( (int32_t)( SysTick->CNT - mid ) < 0 );
            writeVFD(numbers[digitbase]);
            while( (int32_t)( SysTick->CNT - end ) < 0 );
        }
        else if (i2c_registers[MODE] == MODE_DISCRETE)
        {
            if (i2c_registers[INDEX] < 10)
            {
                writeVFD(numbers[i2c_registers[INDEX]]);
            }
        }
    }
}
